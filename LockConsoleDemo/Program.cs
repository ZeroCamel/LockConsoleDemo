using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace LockConsoleDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            string obj = "Hello,World!";
            //将语句块标记为关键部分，放入临界区，获取指定对象的互斥锁，执行语句，然后释放该锁
            //确保一个线程位于代码的关键位置，另一个线程不会进入代码的关键位置，如果其他线程尝试进入
            //锁定的代码，则他将一直等待（被阻止），直到该对象被释放
            //Lock 只能在进程内锁不能跨进程 内部走的是是混合构造，先自旋再转成混合构造
            //自旋锁
            //定义：防止多处理器并发而引入的一种锁，它在内核中多应用于中断处理，单处理器而言，
            //防止中断处理中的并发可简单采用关闭中断的方式，抢占失效
            //目的：保护共享资源而提出的一种锁
            //互斥锁：
            //定义：与自旋锁类似，为了解决某项资源的互斥使用，自旋锁不会引起调用者睡眠，
            //      如果自旋锁已经被其他的执行单元保持，调用者会一直循环判断看自旋锁的保持着是否释放了该锁
            //      低级的保护数据结构和代码片段的原始方式
            //存在问题：
            //死锁
            //过多占用CPU资源
            //使用情况：
            //自旋锁的保持时间较短，因此选择自旋而不是睡眠是十分必要的，效率要高于互斥锁

            //异步锁
            //异步的同步构造，一般的同步构造都是用阻塞线程或者自旋来完成的

            //同步锁
            //


            //注意事项：
            //自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作

            //信号量和读写信号量
            //适用范围：锁的保持时间较长的情况，他们会导致调用者睡眠，因此只能在进程上下文使用，可抢占

            //进程上下文
            //进程可执行活动全过程的静态描述，包含指令和数据，操作类型代码
            //一般程序在用户空间执行当一个程序调用了系统调用或者触发了某个异常，他就陷入了内核空间
            //进程上文-已经执行过的进程指令和数据在相关寄存器与堆栈中的内容
            //进程正文-正在执行的进程指令和数据在相关寄存器与堆栈中的内容
            //进程下文-待执行的进程指令和数据在寄存器和堆栈中的内容

            //在单处理器上，自旋锁仅仅当作一个设置内核抢占的开关。如果内核抢占也不存在，那么自旋锁会在编译时被完全剔除出内核,自旋锁不允许任务睡眠(持有自旋锁的任务睡眠会造成自死锁——因为睡眠有可能造成持有锁的内核任务被重新调度，而再次申请自己已持有的锁
            //SMP-对称多处理系统

            //LOCK是编译语法糖
            //锁的目的是多线程模式下值不被破坏
            //确保代码块完成运行，不会被其他进程中断

            //锁的对象类型
            //1、值类型 编译不通过 即使通过 也会导致Lock失效
            //2、字符串 锁定字符串及其危险 字符串被公共语言运行库CLR暂留 这意味着整个程序中任何给定字符串都只有一个实例
            //          同一对象表示了所有运行的应用程序域的所有线程中的该文本
            lock (obj)
            {
                Console.WriteLine(obj);
            }

            bool isGetLock = false;
            //在线程的命名空间下，提供同步访问对象的机制
            //Enter 获取制定对象的排它锁，并自动设置一个值
            //Ref 通过引用传递参数
            //传递到REF的形参的实参必须先经过实例化，然后才能传递
            //与OUT形参不同在传递之前不需要显示初始化该形参的实参

            //如果传入的类型是值类型 Monitor.Enter会把值类型进行装箱操作，而每次装箱都是不同操作
            //即使编译通过，lock也会失效   
            
            //传值时限制 必须为所在函数类的私有对象

            //Volatile C#限制为4个字节以下的字段才可以使用 
            Monitor.Enter(obj, ref isGetLock);
            try
            {
                Console.WriteLine(obj);
            }
            catch (Exception)
            {

                if (isGetLock)
                {
                    Monitor.Exit(obj);
                }
            }

            Console.ReadKey();
        }
    }
}
